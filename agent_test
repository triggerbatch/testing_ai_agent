import extract_msg

@agent_action
def process_local_email(email_path: str) -> str:
    """
    Reads a local .msg file, extracts mail body, subject, and saves attached PDFs.
    Performs initial validation: stops if no PDF is found.
    :param email_path: The local file path to the .msg file provided by the user.
    :returns: A JSON string containing metadata and a list of local PDF paths, or FAILURE.
    """
    # --- IMPLEMENTATION REQUIRED HERE: LOCAL .MSG READING LOGIC ---
    # 1. Read the .msg file contents.
    # 2. Extract subject and mail body.
    # 3. Extract all attachments.
    
    try:
        # Validate input file path
        if not os.path.exists(email_path):
            return json.dumps({"status": "STOP", "reason": f"Email file not found: {email_path}"})
        
        if not email_path.lower().endswith('.msg'):
            return json.dumps({"status": "STOP", "reason": "File is not a .msg file"})
        
        # Create working directory for attachments
        working_dir = os.path.join(os.path.dirname(email_path), "extracted_attachments")
        os.makedirs(working_dir, exist_ok=True)
        
        # Read and parse the .msg file using extract-msg
        msg = extract_msg.Message(email_path)
        
        # Extract subject and body
        subject = msg.subject or ""
        body = msg.body or ""
        
        # Extract and save attachments
        attachment_paths = []
        if msg.attachments:
            for i, attachment in enumerate(msg.attachments):
                # Get filename
                if hasattr(attachment, 'longFilename') and attachment.longFilename:
                    filename = attachment.longFilename
                elif hasattr(attachment, 'shortFilename') and attachment.shortFilename:
                    filename = attachment.shortFilename
                else:
                    # Generate filename based on attachment type
                    extension = ""
                    if hasattr(attachment, 'data') and len(attachment.data) > 0:
                        # Try to detect file type from first few bytes
                        data_start = attachment.data[:4]
                        if data_start.startswith(b'%PDF'):
                            extension = ".pdf"
                        elif data_start.startswith(b'\x89PNG'):
                            extension = ".png"
                        elif data_start.startswith(b'\xff\xd8\xff'):
                            extension = ".jpg"
                        elif data_start.startswith(b'PK'):
                            extension = ".zip"
                    filename = f"attachment_{i}{extension}"
                
                # Save attachment to working directory
                attachment_path = os.path.join(working_dir, filename)
                
                try:
                    with open(attachment_path, 'wb') as f:
                        f.write(attachment.data)
                    attachment_paths.append(attachment_path)
                except Exception as e:
                    # Continue processing other attachments if one fails
                    print(f"Warning: Failed to save attachment {filename}: {e}")
                    continue
        
        # Close the message to free resources
        msg.close()
        
        extracted_data = {
            "subject": subject,
            "mail_body": body,
            "attachments": attachment_paths
        }
        
    except Exception as e:
        return json.dumps({"status": "STOP", "reason": f"Error processing email: {str(e)}"})
    
    pdf_paths = [path for path in extracted_data['attachments'] if path.lower().endswith('.pdf')]
    
    # Validation: Stop if no PDF found
    if not pdf_paths:
        return json.dumps({"status": "STOP", "reason": "No PDF attachments found in email."})
    
    return json.dumps({
        "status": "SUCCESS",
        "metadata": {
            "subject": extracted_data["subject"],
            "mail_body": extracted_data["mail_body"]
        },
        "pdf_paths": pdf_paths
    })
